# TODO FIXME XXX: The scalar sB needs to be the same, but the rB/mB values can actually change!!??
import random

from curves import *
from util import *
from encode import *
from weaver import *

# ----------------------------------------[ Dragonfly Functions ]---------------------------------------------

def simplified_swu(u, p, a, b, z):
	m = (pow(z, 2, p) * pow(u, 4, p) + z * pow(u, 2, p)) % p
	l = ceq(m, 0)
	t = pow(m, p - 2, p)
	x1 = csel(l, (b * pow(z * a, p - 2, p)) % p, ((-b * (1 + t) * pow(a, p - 2, p)) % p))
	gx1 = (pow(x1, 3, p) + a * x1 + b) % p
	x2 = (z * pow(u, 2, p) * x1) % p
	gx2 = (pow(x2, 3, p) + a * x2 + b) % p
	l = is_quadratic_residue(gx1, p)
	v = csel(l, gx1, gx2)
	x = csel(l, x1, x2)
	y = modular_sqrt(v, p)
	l = ceq(lsb(u), lsb(y))
	return (x, y) if l else (x, p - y)

def hash_to_element(ssid, key, identifier, curve_name):
	p, a, b, _, z = curve_params[curve_name]
	ssid_bytes = ssid.encode()
	key_bytes = key.encode()
	if identifier:
		key_bytes += identifier
	pwd_seed = hkdf_extract(ssid_bytes, key_bytes)
	len_ = len(int_to_bytes(p, (p.bit_length() + 7) // 8)) * 3 // 2
	pwd_value1 = hkdf_expand(pwd_seed, b"SAE Hash to Element u1 P1", len_)
	u1 = bytes_to_int(pwd_value1) % p
	P1 = simplified_swu(u1, p, a, b, z)
	pwd_value2 = hkdf_expand(pwd_seed, b"SAE Hash to Element u2 P2", len_)
	u2 = bytes_to_int(pwd_value2) % p
	P2 = simplified_swu(u2, p, a, b, z)
	return ECC.EccPoint(P1[0], P1[1], curve_name) + ECC.EccPoint(P2[0], P2[1], curve_name)

def get_commit_info(P, rand=None, mask=None, curve_name="secp256r1"):
	# TODO: We can get the curve from element P, and use that form everywhere
	"""Generate a new commit message for a given element P"""
	group_prime, _, _, curve_order, _ = curve_params[curve_name]

	if rand == None or mask == None:
		rand = random.randint(2, curve_order)
		mask = random.randint(2, curve_order)

	# commit-scalar = (rand + mask) mod r
	scalar = (rand + mask) % curve_order

	# Element E = - m * P. Recall that negation of EC points means negating the y coordinate.
	# Negating the y coordinate means calculating (group_prime - Y coordinate).
	element = - P * mask

	return rand, mask, scalar, element


def calc_k_kck_pmk(pwe, peer_element, peer_scalar, my_rand, my_scalar, curve_name):
	k = ((pwe * peer_scalar + peer_element) * my_rand).x

	# TODO: Better selection of the order r
	keyseed = HMAC256(b"\x00" * 32, int_to_bytes(k, 64))
	if '256' in curve_name:
		kck_and_pmk = KDF_Length(keyseed, b"SAE KCK and PMK",
							 int_to_bytes((my_scalar + peer_scalar) % secp256r1_r, 64), 512)
	elif '224' in curve_name:
		kck_and_pmk = KDF_Length(keyseed, b"SAE KCK and PMK",
							 int_to_bytes((my_scalar + peer_scalar) % secp224r1_r, 64), 512)
	kck = kck_and_pmk[0:32]
	pmk = kck_and_pmk[32:]

	return k, kck, pmk


def calculate_confirm_hash(kck, send_confirm, scalar, element, peer_scalar, peer_element):
	return HMAC256(kck, struct.pack("<H", send_confirm) + int_to_bytes(scalar, 64) + point_to_bytes(element, 64)
						+ int_to_bytes(peer_scalar, 64) + point_to_bytes(peer_element, 64))


# ----------------------------------------[ Dragonfleet Functions ]---------------------------------------------

NUM_KEYS = 6			# Number of simultaneous keys supported
CLIENT_INDEX = 3		# The key used by the client (0-based index)
NETWORK_NAME = "testnetwork"	# Name of the simulated network

set_log_level(DEBUG)

# Generate random keys
log(INFO, f"[AP]  Generating {NUM_KEYS} keys")
keys = []
for i in range(NUM_KEYS):
    keys.append(f"key_{i}_{random.randint(0,1000)}")

# Generate the element P that the client will use
PA = hash_to_element(NETWORK_NAME, keys[CLIENT_INDEX], None, 'secp256r1')

# Simulate commit frame from client to AP, so all the *A variables are generated by the client
rA, mA, sA, EA = get_commit_info(PA)
log(INFO,  f"[STA] Sending Commit frame to AP", color="green")
log(DEBUG, f"[STA]    rA = {rA}")
log(DEBUG, f"[STA]    mA = {mA}")
log(DEBUG, f"[STA]    sA = {sA}")
log(DEBUG, f"[STA]    EA = {int(EA.x):X}, {int(EA.y):X}")

# Simulate the AP that will generate all elements. They will all use a shared scalar.
# These will then be encoded to values.
commit_frames = []
for i in range(NUM_KEYS):
    # TODO FIXME XXX: The scalar sB needs to be the same, but the rB/mB values can actually change!!
    P = hash_to_element(NETWORK_NAME, keys[i], None, 'secp256r1')
    if i == 0:
        commit_info = get_commit_info(P)
        rB, mB, sB, _ = commit_info
    else:
        commit_info = get_commit_info(P, rB, mB)
        assert sB == commit_info[2]

    commit_frames.append((commit_info))
log(INFO,  f"[AP]  Generated global scalar sB")
log(DEBUG, f"[AP]     sB = {sB}")
log(INFO,  f"[AP]  Generated Element EB for each key")

# Encode the elliptic curve points to be the y-values in the O-PAKE-style encoding.
u_values = []
v_values = []
for i in range(NUM_KEYS):
    EBi = commit_frames[i][3] 
    point = (int(EBi.x), int(EBi.y))
    u, v = point_to_values(point, secp256r1_a, secp256r1_b, secp256r1_p)
    u_values.append(u)
    v_values.append(v)
log(INFO,  f"[AP]  Encoded all EB points to values")

# Hash all the keys. These will be the x-values in the O-PAKE-style weave function.
pwd_hashes = []
for i in range(NUM_KEYS):
    pwd_hashes.append(hash_pw_mod(keys[i], secp256r1_p))

# Precompute the weave matrix, and then weave the value encodings
matrix = precompute(pwd_hashes, secp256r1_p)
coeff_u = waever(u_values, matrix, secp256r1_p)
coeff_v = waever(v_values, matrix, secp256r1_p)
log(INFO,  f"[AP]  Sending all values to the client", color="green")

# Verify that the client can recover all encoded points based on the hashed keys,
# and simulate continuing with the specific decoded_EB based on the specific client key.
decoded_EB = None
for i in range(NUM_KEYS):
    u = eval_weave(coeff_u, pwd_hashes[i], secp256r1_p)
    v = eval_weave(coeff_v, pwd_hashes[i], secp256r1_p)
    
    EBi_x, EBi_y = values_to_point((u, v), secp256r1_a, secp256r1_b, secp256r1_p)
    assert EBi_x == int(commit_frames[i][3].x), f"{EBi_x} != {int(commit_frames[i][3].x)}"
    assert EBi_y == int(commit_frames[i][3].y), f"{EBi_x} != {int(commit_frames[i][3].y)}"
    
    if i == CLIENT_INDEX:
        log(INFO,  f"[STA] Retrieved the decoded EB element based on the received values")
        log(DEBUG, f"[STA]    Decoded EB = {EBi_x:X}, {EBi_y:X}")
        decoded_EB = ECC.EccPoint(EBi_x, EBi_y, "secp256r1")
        assert decoded_EB.x == commit_frames[i][3].x
        assert decoded_EB.y == commit_frames[i][3].y

# Based on decoded_EB, the client's own commit frame, and the AP's global scalar,
# the Confirm frame sent by the client is now calculated.
rB, mB, sB, EB = commit_frames[CLIENT_INDEX]

# Internal sanity check
K_client = rA * (sB * PA + decoded_EB)
K_ap     = rB * (sA * PA + EA)
assert K_client.x == K_ap.x, f"{K_client.x} != {K_ap.x}"

# The client calculates the session key
client_k, client_kck, client_pmk = calc_k_kck_pmk(
					pwe=PA,
					peer_element=decoded_EB,
					peer_scalar=sB,
					my_rand=rA,
					my_scalar=sA,
					curve_name="secp256r1")
# The client calculates the confirm value
send_confirm = 1	# Acts as a replay counter
client_confirm = calculate_confirm_hash(client_kck, send_confirm, sA, EA, sB, decoded_EB)
log(INFO,  f"[STA] Calculated the negotiated key and the KCK and PMK keys")
log(DEBUG, f"[STA]    client_k = {int(client_k)}")
log(INFO,  f"[STA] Sending the calculated the confirm value to the AP", color="green")
log(DEBUG, f"[STA]    client_confirm = {client_confirm.hex()}")

# The AP now takes the client_confirm value, and searches for the key that was used.
# Do this in a random order to avoid timing attacks that might reveal the key index being used.
used_key_idx = None
log(INFO,  f"[AP]  Finding matching confirm value...")
indices = list(range(NUM_KEYS))
random.shuffle(indices)
for i in indices:
	PB = hash_to_element(NETWORK_NAME, keys[i], None, 'secp256r1')
	rB, mB, sB, EB = commit_frames[i]
	ap_k, ap_kck, ap_pmk = calc_k_kck_pmk(
					pwe=PB,
					peer_element=EA,
					peer_scalar=sA,
					my_rand=rB,
					my_scalar=sB,
					curve_name="secp256r1")
	ap_confirm = calculate_confirm_hash(ap_kck, send_confirm, sA, EA, sB, EB)
	log(DEBUG, f"[AP]      Calculated confirm value {ap_confirm.hex()}")
	if client_confirm == ap_confirm:
		log(INFO, f"[AP]  Confirmed key!")
		used_key_idx = i
		break

if used_key_idx == None:
	log(ERROR, "ERORR: Failed to find the key used by the client!")
	quit(1)

# Switch the peer order and send back a confirm
client_confirm = calculate_confirm_hash(client_kck, send_confirm, sB, EB, sA, EA)
log(INFO, f"[AP]  Sending confirm value to the client", color="green")

